## 题目



## 自解：

思路：看到矩阵，寻路，想到了dfs的方法，用dfs去实现

```c++
class Solution {
public:
    int movingCount(int m, int n, int k) {
        vector<vector<int>> board(m, vector<int>(n, 0));
        int result=0;
        dfs(board, 0, 0, k, result);
        return result;
    }

    void dfs(vector<vector<int>> &board, int ir, int ic, int k, int &result)
    {
        int row = board.size();
        int col = board[0].size();
        if(transNum(ir)+transNum(ic) > k)
        {
            return;
        }

        if(ir<0 || ir>=row || ic<0 || ic>=col || board[ir][ic] == 1) //把越界条件写在前面，防止访问越界，访问过的点标记为1
        {
            return;
        }

        board[ir][ic]=1;  //访问过的点标记为1
        result++;
        dfs(board, ir+1, ic, k, result);
        dfs(board, ir-1, ic, k, result);
        dfs(board, ir, ic-1, k, result);
        dfs(board, ir, ic+1, k, result);

    }

    int transNum(int inNum) //辅助函数：转换坐标-》坐标位数之和
    {
        int sum=0;
        while(inNum !=0)
        {
            sum+= inNum%10;
            inNum /= 10;
        }
        return sum;
    }
};
```





## 官方解释：