## 题目

![](C:\kuangStudy\图片\34.1.png)

## 自解

总结：队列层序遍历实现，想法是先求出输出的第一行的所有字符的下标，然后将他们的下标每个压入两个，压入队列，然后循环，队列每次读出两个数，前一个数执行减1，后一个数执行加1，如果减法减到负数则压入一个非法的数，用于后面除去，同理，如果加法加到的数大于输入字符串的长度也是压入一个非法的值

```c++

```




## 官解

总结：优雅地利用了数据结构，建立了一个string的向量组，用于记录每一行的字符，同时通过一个goingDown的flag来控制行号的切换，十分巧妙

```c++
class Solution {
public:
    string convert(string s, int numRows) {

        if (numRows == 1) return s;

        vector<string> rows(min(numRows, int(s.size())));
        int curRow = 0;
        bool goingDown = false;

        for (char c : s) {
            rows[curRow] += c;
            if (curRow == 0 || curRow == numRows - 1) goingDown = !goingDown;
            curRow += goingDown ? 1 : -1;
        }

        string ret;
        for (string row : rows) ret += row;
        return ret;
    }
};

作者：LeetCode
链接：https://leetcode-cn.com/problems/zigzag-conversion/solution/z-zi-xing-bian-huan-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

**复杂度分析**

- 时间复杂度：O*(*n*)，其中 n*==len(*s*)
- 空间复杂度：O*(*n)


