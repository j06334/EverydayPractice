## 题目：

亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。

游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。

亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。

假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。



## 示例输入

输入：[5,3,4,5]
输出：true
解释：
亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。
假设他取了前 5 颗，这一行就变成了 [3,4,5] 。
如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。
如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。
这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/stone-game
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

## 提示：

- `2 <= piles.length <= 500`
- `piles.length` 是偶数。
- `1 <= piles[i] <= 500`
- `sum(piles)` 是奇数。





## 分析：

**方法一：动态规划**

由于每次只能从行的开始或结束处取走整堆石子，因此可以保证剩下的石子堆一定是连续的。

如果只剩下一堆石子，则当前玩家只能取走这堆石子。如果剩下多堆石子，则当前玩家可以选择从行的开始或结束处取走整堆石子，然后轮到另一个玩家在剩下的石子堆中取走石子。这是一个递归的过程，因此可以使用递归进行求解，递归过程中维护一个总数，表示Alex 和Lee 的石子数量之差，当游戏结束时，如果总数大于 0，则Alex 赢得比赛，否则Lee 赢得比赛。

如果有 n堆石子，则递归的时间复杂度为 O(2^n)无法通过所有的测试用例。递归的时间复杂度高的原因是存在大量重复计算。由于存在重复子问题，因此可以使用动态规划降低时间复杂度。

定义二维数组dp，其行数和列数都等于石子的堆数，**dp[i] [j] 表示仅取走下标 i 到 j 的石堆时**，**最终两位玩家的石子数的最大差**(**即两位玩家都执行了当前最优解，差值为Alex-Lee)**，注意当前玩家不一定是先手Alex。

只有当 i≤j 时，剩下的石子堆才有意义，因此当 i>j时，dp[i] [j]=0。

当 i=j 时，说明只取走1堆石子，当前玩家只能取走这堆石子，因此对于所有 0≤i<piles.length，都有 dp[i] [i]=piles[i]。

当 i<j 时，当前玩家可以选择取走piles[i] 或 piles[j]，然后轮到另一个玩家在剩下的石子堆中取走石子。在两种方案中，当前玩家会选择最优的方案，使得自己的石子数量最大化。因此可以得到如下状态转移方程：

```c++
dp[i][j]=max(piles[i]−dp[i+1][j],  piles[j]−dp[i][j−1])  //注意dp的定义，因此d[i][j]等于下一位玩家拿了piles[i]减去此前两个玩家的最大差                                                               //dp[i+1][j]，相当于弥补了一部分最大差了
```

最后判断dp[0] [piles.length−1] 的值，如果大于 0，则 Alex 的石子数量大于Lee 的石子数量，因此 Alex 赢得比赛，否则 Lee 赢得比赛。



理解了dp的含义之后，编程就变得明朗了

```c++
class Solution {
public:
    bool stoneGame(vector<int>& piles) {
        int length = piles.size();
        auto dp = vector<vector<int>>(length, vector<int>(length));
        for(int i=0; i<length; i++)
        {
            dp[i][i]=piles[i];
        }
        for(int i=length-2; i>=0; i--)
        {
            for(int j=i+1; j<length; j++)
            {
                dp[i][j]= max(piles[i]-dp[i+1][j], piles[j]-dp[i][j-1]);
            }
        }
        
        return dp[0][length-1]>0;
    }
}
        
```



**方法二：数学分析法**

- 将初始状态的石堆标个号，第一堆为1，依次到n，n为偶数，总的石子数按题目说是奇数
- 分析：石堆其实按原始编号，可以分成**两组**，一组是拥有奇数编号的(1,3,5)，另外一组是拥有偶数编号的(2,4,6)，而石子的总数是奇数的，必定会导致其中一组的石子比另外一组的石子多；
- Alex必定先手的话，他其实可以选择某一组(奇数组或偶数组)的石子全拿了，可以画图分析一下，很容易看出；
- 那么他能够一下看到全部石堆的话(并且算出哪一组的石子总数多2333)，他只要只拿某一组的石子，就能够获胜；



作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/stone-game/solution/shi-zi-you-xi-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。